#ifndef UNREALSDK_UNREAL_WRAPPERS_WEAK_POINTER_H
#define UNREALSDK_UNREAL_WRAPPERS_WEAK_POINTER_H

#include "unrealsdk/pch.h"

#if UNREALSDK_FLAVOUR == UNREALSDK_FLAVOUR_WILLOW
#define UNREALSDK_EMULATED_WEAK_POINTER
#endif

#ifdef UNREALSDK_EMULATED_WEAK_POINTER
#include "unrealsdk/unreal/structs/fname.h"
#else
#include "unrealsdk/unreal/structs/fweakobjectptr.h"
#endif

namespace unrealsdk::unreal {

class UObject;

/**
Class which holds a weak reference to an unreal object.

Under Unreal 3 this is emulated, as there's no built in support for weak references. This means
there's a very rare chance that this returns a different object than what was it was set to, however
it will be near identical, and it will always be a valid object.

Note that there's no way to get a strong reference to an unreal object. This means if you're using
this on a thread, it's always possible for the engine to pull the object out from under you after
you retrieve it. However, it *should* be safe under a hook, since the GC shouldn't be running.
*/
struct WeakPointer {
   private:
#ifdef UNREALSDK_EMULATED_WEAK_POINTER
    // The main way this works is just to store the object's index into gobjects, which we can
    // safely retrieve. A problem with this is another object might get put into the same index
    // though, so we also copy a bunch of other information that should help "uniquely" identify it.

    // No storing real pointers to prevent dereferencing them, they may become invalid.

    size_t index{};

    // Most obviously, if a new object is at the same index, it's address is likely different.
    // Use an address of 0 as the null sentinel, since index 0 may be valid.
    uintptr_t obj_addr = 0;

    // A lot of transient objects are stored under a transient `PersistentLevel` package, which
    // should also change whenever you change levels.
    uintptr_t outer_addr{};

    // Make sure the type still lines up - two classes might share a vftable so safer to check both.
    uintptr_t vftable_addr{};
    uintptr_t class_addr{};

    // Most names are unique, a lot of transients use an autogenerated name with an incrementing
    // number, so this should help catch out a few more cases.
    FName name;

#else
    FWeakObjectPtr ptr{};
#endif

   public:
    /**
     * @brief Constructs a new weak pointer.
     *
     * @param obj The object it should reference.
     * @param other The other weak pointer to copy/move from.
     */
    WeakPointer(void) = default;
    WeakPointer(const UObject* obj);
    WeakPointer(const WeakPointer& other) = default;
    WeakPointer(WeakPointer&& other) noexcept = default;

    /**
     * @brief Assigns a new object to this pointer.
     *
     * @param obj The object it should reference.
     * @param other The other weak pointer to copy/move from.
     * @return A reference to this pointer.
     */
    WeakPointer& operator=(const UObject* obj);
    WeakPointer& operator=(const WeakPointer& other) = default;
    WeakPointer& operator=(WeakPointer&& other) noexcept = default;

    /**
     * @brief Destroys this object.
     */
    ~WeakPointer(void) = default;

    /**
     * @brief Gets the referenced object, which may be null.
     * @note If the object is null, accessing via the mutable version optimizes future accesses.
     *
     * @return The referenced object.
     */
    [[nodiscard]] UObject* operator*(void);
    [[nodiscard]] UObject* operator*(void) const;

    /**
     * @brief Checks if this holds a valid object.
     *
     * @return True if this holds a valid object, false if it's null.
     */
    [[nodiscard]] operator bool(void);
    [[nodiscard]] operator bool(void) const;
};

}  // namespace unrealsdk::unreal

#endif /* UNREALSDK_UNREAL_WRAPPERS_WEAK_POINTER_H */
